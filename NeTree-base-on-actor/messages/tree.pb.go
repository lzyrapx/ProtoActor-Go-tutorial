// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tree.proto

package messages

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Add struct {
	Key   int32  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Add) Reset()      { *m = Add{} }
func (*Add) ProtoMessage() {}
func (*Add) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{0}
}
func (m *Add) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Add) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Add.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Add) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Add.Merge(m, src)
}
func (m *Add) XXX_Size() int {
	return m.Size()
}
func (m *Add) XXX_DiscardUnknown() {
	xxx_messageInfo_Add.DiscardUnknown(m)
}

var xxx_messageInfo_Add proto.InternalMessageInfo

func (m *Add) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Add) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type SuccessAdd struct {
	Key   int32  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SuccessAdd) Reset()      { *m = SuccessAdd{} }
func (*SuccessAdd) ProtoMessage() {}
func (*SuccessAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{1}
}
func (m *SuccessAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuccessAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuccessAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessAdd.Merge(m, src)
}
func (m *SuccessAdd) XXX_Size() int {
	return m.Size()
}
func (m *SuccessAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessAdd.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessAdd proto.InternalMessageInfo

func (m *SuccessAdd) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *SuccessAdd) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Find struct {
	Key int32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *Find) Reset()      { *m = Find{} }
func (*Find) ProtoMessage() {}
func (*Find) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{2}
}
func (m *Find) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Find) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Find.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Find) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Find.Merge(m, src)
}
func (m *Find) XXX_Size() int {
	return m.Size()
}
func (m *Find) XXX_DiscardUnknown() {
	xxx_messageInfo_Find.DiscardUnknown(m)
}

var xxx_messageInfo_Find proto.InternalMessageInfo

func (m *Find) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

type SuccessFindValue struct {
	Key   int32  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SuccessFindValue) Reset()      { *m = SuccessFindValue{} }
func (*SuccessFindValue) ProtoMessage() {}
func (*SuccessFindValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{3}
}
func (m *SuccessFindValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessFindValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuccessFindValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuccessFindValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessFindValue.Merge(m, src)
}
func (m *SuccessFindValue) XXX_Size() int {
	return m.Size()
}
func (m *SuccessFindValue) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessFindValue.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessFindValue proto.InternalMessageInfo

func (m *SuccessFindValue) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *SuccessFindValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type KeyValue struct {
	Key   int32  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KeyValue) Reset()      { *m = KeyValue{} }
func (*KeyValue) ProtoMessage() {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{4}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *KeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type SetParentID struct {
}

func (m *SetParentID) Reset()      { *m = SetParentID{} }
func (*SetParentID) ProtoMessage() {}
func (*SetParentID) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{5}
}
func (m *SetParentID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetParentID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetParentID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetParentID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetParentID.Merge(m, src)
}
func (m *SetParentID) XXX_Size() int {
	return m.Size()
}
func (m *SetParentID) XXX_DiscardUnknown() {
	xxx_messageInfo_SetParentID.DiscardUnknown(m)
}

var xxx_messageInfo_SetParentID proto.InternalMessageInfo

type SetParentIDCustom struct {
	Pid     string `protobuf:"bytes,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *SetParentIDCustom) Reset()      { *m = SetParentIDCustom{} }
func (*SetParentIDCustom) ProtoMessage() {}
func (*SetParentIDCustom) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{6}
}
func (m *SetParentIDCustom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetParentIDCustom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetParentIDCustom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetParentIDCustom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetParentIDCustom.Merge(m, src)
}
func (m *SetParentIDCustom) XXX_Size() int {
	return m.Size()
}
func (m *SetParentIDCustom) XXX_DiscardUnknown() {
	xxx_messageInfo_SetParentIDCustom.DiscardUnknown(m)
}

var xxx_messageInfo_SetParentIDCustom proto.InternalMessageInfo

func (m *SetParentIDCustom) GetPid() string {
	if m != nil {
		return m.Pid
	}
	return ""
}

func (m *SetParentIDCustom) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type Traverse struct {
}

func (m *Traverse) Reset()      { *m = Traverse{} }
func (*Traverse) ProtoMessage() {}
func (*Traverse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{7}
}
func (m *Traverse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Traverse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Traverse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Traverse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Traverse.Merge(m, src)
}
func (m *Traverse) XXX_Size() int {
	return m.Size()
}
func (m *Traverse) XXX_DiscardUnknown() {
	xxx_messageInfo_Traverse.DiscardUnknown(m)
}

var xxx_messageInfo_Traverse proto.InternalMessageInfo

type TraverseResponse struct {
	KvPair []*KeyValue `protobuf:"bytes,1,rep,name=kvPair,proto3" json:"kvPair,omitempty"`
}

func (m *TraverseResponse) Reset()      { *m = TraverseResponse{} }
func (*TraverseResponse) ProtoMessage() {}
func (*TraverseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{8}
}
func (m *TraverseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraverseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraverseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraverseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraverseResponse.Merge(m, src)
}
func (m *TraverseResponse) XXX_Size() int {
	return m.Size()
}
func (m *TraverseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TraverseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TraverseResponse proto.InternalMessageInfo

func (m *TraverseResponse) GetKvPair() []*KeyValue {
	if m != nil {
		return m.KvPair
	}
	return nil
}

type Trees struct {
}

func (m *Trees) Reset()      { *m = Trees{} }
func (*Trees) ProtoMessage() {}
func (*Trees) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{9}
}
func (m *Trees) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trees) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trees.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trees) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trees.Merge(m, src)
}
func (m *Trees) XXX_Size() int {
	return m.Size()
}
func (m *Trees) XXX_DiscardUnknown() {
	xxx_messageInfo_Trees.DiscardUnknown(m)
}

var xxx_messageInfo_Trees proto.InternalMessageInfo

type TreesResponse struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *TreesResponse) Reset()      { *m = TreesResponse{} }
func (*TreesResponse) ProtoMessage() {}
func (*TreesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{10}
}
func (m *TreesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TreesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreesResponse.Merge(m, src)
}
func (m *TreesResponse) XXX_Size() int {
	return m.Size()
}
func (m *TreesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TreesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TreesResponse proto.InternalMessageInfo

func (m *TreesResponse) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TreesResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type SendBackTreeResponse struct {
	Trees []*TreesResponse `protobuf:"bytes,1,rep,name=trees,proto3" json:"trees,omitempty"`
}

func (m *SendBackTreeResponse) Reset()      { *m = SendBackTreeResponse{} }
func (*SendBackTreeResponse) ProtoMessage() {}
func (*SendBackTreeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{11}
}
func (m *SendBackTreeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendBackTreeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendBackTreeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendBackTreeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendBackTreeResponse.Merge(m, src)
}
func (m *SendBackTreeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendBackTreeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendBackTreeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendBackTreeResponse proto.InternalMessageInfo

func (m *SendBackTreeResponse) GetTrees() []*TreesResponse {
	if m != nil {
		return m.Trees
	}
	return nil
}

type LookingForKeyLeft struct {
}

func (m *LookingForKeyLeft) Reset()      { *m = LookingForKeyLeft{} }
func (*LookingForKeyLeft) ProtoMessage() {}
func (*LookingForKeyLeft) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{12}
}
func (m *LookingForKeyLeft) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LookingForKeyLeft) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LookingForKeyLeft.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LookingForKeyLeft) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LookingForKeyLeft.Merge(m, src)
}
func (m *LookingForKeyLeft) XXX_Size() int {
	return m.Size()
}
func (m *LookingForKeyLeft) XXX_DiscardUnknown() {
	xxx_messageInfo_LookingForKeyLeft.DiscardUnknown(m)
}

var xxx_messageInfo_LookingForKeyLeft proto.InternalMessageInfo

type LookingForKeyRight struct {
}

func (m *LookingForKeyRight) Reset()      { *m = LookingForKeyRight{} }
func (*LookingForKeyRight) ProtoMessage() {}
func (*LookingForKeyRight) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{13}
}
func (m *LookingForKeyRight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LookingForKeyRight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LookingForKeyRight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LookingForKeyRight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LookingForKeyRight.Merge(m, src)
}
func (m *LookingForKeyRight) XXX_Size() int {
	return m.Size()
}
func (m *LookingForKeyRight) XXX_DiscardUnknown() {
	xxx_messageInfo_LookingForKeyRight.DiscardUnknown(m)
}

var xxx_messageInfo_LookingForKeyRight proto.InternalMessageInfo

type ErrorFindingValue struct {
}

func (m *ErrorFindingValue) Reset()      { *m = ErrorFindingValue{} }
func (*ErrorFindingValue) ProtoMessage() {}
func (*ErrorFindingValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{14}
}
func (m *ErrorFindingValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorFindingValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorFindingValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrorFindingValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorFindingValue.Merge(m, src)
}
func (m *ErrorFindingValue) XXX_Size() int {
	return m.Size()
}
func (m *ErrorFindingValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorFindingValue.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorFindingValue proto.InternalMessageInfo

type DeleteKey struct {
	IsLeft bool  `protobuf:"varint,1,opt,name=isLeft,proto3" json:"isLeft,omitempty"`
	Key    int32 `protobuf:"varint,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *DeleteKey) Reset()      { *m = DeleteKey{} }
func (*DeleteKey) ProtoMessage() {}
func (*DeleteKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{15}
}
func (m *DeleteKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteKey.Merge(m, src)
}
func (m *DeleteKey) XXX_Size() int {
	return m.Size()
}
func (m *DeleteKey) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteKey.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteKey proto.InternalMessageInfo

func (m *DeleteKey) GetIsLeft() bool {
	if m != nil {
		return m.IsLeft
	}
	return false
}

func (m *DeleteKey) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

type CouldNotFindKey struct {
}

func (m *CouldNotFindKey) Reset()      { *m = CouldNotFindKey{} }
func (*CouldNotFindKey) ProtoMessage() {}
func (*CouldNotFindKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{16}
}
func (m *CouldNotFindKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CouldNotFindKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CouldNotFindKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CouldNotFindKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CouldNotFindKey.Merge(m, src)
}
func (m *CouldNotFindKey) XXX_Size() int {
	return m.Size()
}
func (m *CouldNotFindKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CouldNotFindKey.DiscardUnknown(m)
}

var xxx_messageInfo_CouldNotFindKey proto.InternalMessageInfo

type Cleanup struct {
	WasLeft bool `protobuf:"varint,1,opt,name=wasLeft,proto3" json:"wasLeft,omitempty"`
}

func (m *Cleanup) Reset()      { *m = Cleanup{} }
func (*Cleanup) ProtoMessage() {}
func (*Cleanup) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{17}
}
func (m *Cleanup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cleanup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cleanup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cleanup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cleanup.Merge(m, src)
}
func (m *Cleanup) XXX_Size() int {
	return m.Size()
}
func (m *Cleanup) XXX_DiscardUnknown() {
	xxx_messageInfo_Cleanup.DiscardUnknown(m)
}

var xxx_messageInfo_Cleanup proto.InternalMessageInfo

func (m *Cleanup) GetWasLeft() bool {
	if m != nil {
		return m.WasLeft
	}
	return false
}

type FinalCleanup struct {
	Pid       string `protobuf:"bytes,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Address   string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	SetToLeft bool   `protobuf:"varint,3,opt,name=SetToLeft,proto3" json:"SetToLeft,omitempty"`
}

func (m *FinalCleanup) Reset()      { *m = FinalCleanup{} }
func (*FinalCleanup) ProtoMessage() {}
func (*FinalCleanup) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{18}
}
func (m *FinalCleanup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalCleanup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalCleanup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalCleanup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalCleanup.Merge(m, src)
}
func (m *FinalCleanup) XXX_Size() int {
	return m.Size()
}
func (m *FinalCleanup) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalCleanup.DiscardUnknown(m)
}

var xxx_messageInfo_FinalCleanup proto.InternalMessageInfo

func (m *FinalCleanup) GetPid() string {
	if m != nil {
		return m.Pid
	}
	return ""
}

func (m *FinalCleanup) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *FinalCleanup) GetSetToLeft() bool {
	if m != nil {
		return m.SetToLeft
	}
	return false
}

type SetLeftMaxKey struct {
	Key int32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *SetLeftMaxKey) Reset()      { *m = SetLeftMaxKey{} }
func (*SetLeftMaxKey) ProtoMessage() {}
func (*SetLeftMaxKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{19}
}
func (m *SetLeftMaxKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetLeftMaxKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetLeftMaxKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetLeftMaxKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetLeftMaxKey.Merge(m, src)
}
func (m *SetLeftMaxKey) XXX_Size() int {
	return m.Size()
}
func (m *SetLeftMaxKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SetLeftMaxKey.DiscardUnknown(m)
}

var xxx_messageInfo_SetLeftMaxKey proto.InternalMessageInfo

func (m *SetLeftMaxKey) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

type SetNewRoot struct {
	Pid                   string `protobuf:"bytes,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Address               string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	CustomPidToDelete     string `protobuf:"bytes,3,opt,name=customPidToDelete,proto3" json:"customPidToDelete,omitempty"`
	CustomAddressToDelete string `protobuf:"bytes,4,opt,name=customAddressToDelete,proto3" json:"customAddressToDelete,omitempty"`
}

func (m *SetNewRoot) Reset()      { *m = SetNewRoot{} }
func (*SetNewRoot) ProtoMessage() {}
func (*SetNewRoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{20}
}
func (m *SetNewRoot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetNewRoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetNewRoot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetNewRoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetNewRoot.Merge(m, src)
}
func (m *SetNewRoot) XXX_Size() int {
	return m.Size()
}
func (m *SetNewRoot) XXX_DiscardUnknown() {
	xxx_messageInfo_SetNewRoot.DiscardUnknown(m)
}

var xxx_messageInfo_SetNewRoot proto.InternalMessageInfo

func (m *SetNewRoot) GetPid() string {
	if m != nil {
		return m.Pid
	}
	return ""
}

func (m *SetNewRoot) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *SetNewRoot) GetCustomPidToDelete() string {
	if m != nil {
		return m.CustomPidToDelete
	}
	return ""
}

func (m *SetNewRoot) GetCustomAddressToDelete() string {
	if m != nil {
		return m.CustomAddressToDelete
	}
	return ""
}

type InfoSetLeftMaxKey struct {
}

func (m *InfoSetLeftMaxKey) Reset()      { *m = InfoSetLeftMaxKey{} }
func (*InfoSetLeftMaxKey) ProtoMessage() {}
func (*InfoSetLeftMaxKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{21}
}
func (m *InfoSetLeftMaxKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoSetLeftMaxKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoSetLeftMaxKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfoSetLeftMaxKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoSetLeftMaxKey.Merge(m, src)
}
func (m *InfoSetLeftMaxKey) XXX_Size() int {
	return m.Size()
}
func (m *InfoSetLeftMaxKey) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoSetLeftMaxKey.DiscardUnknown(m)
}

var xxx_messageInfo_InfoSetLeftMaxKey proto.InternalMessageInfo

type InfoSetLeftMaxKeyResponse struct {
	Key int32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *InfoSetLeftMaxKeyResponse) Reset()      { *m = InfoSetLeftMaxKeyResponse{} }
func (*InfoSetLeftMaxKeyResponse) ProtoMessage() {}
func (*InfoSetLeftMaxKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{22}
}
func (m *InfoSetLeftMaxKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoSetLeftMaxKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoSetLeftMaxKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfoSetLeftMaxKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoSetLeftMaxKeyResponse.Merge(m, src)
}
func (m *InfoSetLeftMaxKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *InfoSetLeftMaxKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoSetLeftMaxKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InfoSetLeftMaxKeyResponse proto.InternalMessageInfo

func (m *InfoSetLeftMaxKeyResponse) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

type CreateNewTreeForCLI struct {
	LeafSize int32 `protobuf:"varint,1,opt,name=leafSize,proto3" json:"leafSize,omitempty"`
}

func (m *CreateNewTreeForCLI) Reset()      { *m = CreateNewTreeForCLI{} }
func (*CreateNewTreeForCLI) ProtoMessage() {}
func (*CreateNewTreeForCLI) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{23}
}
func (m *CreateNewTreeForCLI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateNewTreeForCLI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateNewTreeForCLI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateNewTreeForCLI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateNewTreeForCLI.Merge(m, src)
}
func (m *CreateNewTreeForCLI) XXX_Size() int {
	return m.Size()
}
func (m *CreateNewTreeForCLI) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateNewTreeForCLI.DiscardUnknown(m)
}

var xxx_messageInfo_CreateNewTreeForCLI proto.InternalMessageInfo

func (m *CreateNewTreeForCLI) GetLeafSize() int32 {
	if m != nil {
		return m.LeafSize
	}
	return 0
}

type CreateNewTreeResponse struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *CreateNewTreeResponse) Reset()      { *m = CreateNewTreeResponse{} }
func (*CreateNewTreeResponse) ProtoMessage() {}
func (*CreateNewTreeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{24}
}
func (m *CreateNewTreeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateNewTreeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateNewTreeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateNewTreeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateNewTreeResponse.Merge(m, src)
}
func (m *CreateNewTreeResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateNewTreeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateNewTreeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateNewTreeResponse proto.InternalMessageInfo

func (m *CreateNewTreeResponse) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CreateNewTreeResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type InsertCLI struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Key   int32  `protobuf:"varint,3,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *InsertCLI) Reset()      { *m = InsertCLI{} }
func (*InsertCLI) ProtoMessage() {}
func (*InsertCLI) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{25}
}
func (m *InsertCLI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertCLI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertCLI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertCLI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertCLI.Merge(m, src)
}
func (m *InsertCLI) XXX_Size() int {
	return m.Size()
}
func (m *InsertCLI) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertCLI.DiscardUnknown(m)
}

var xxx_messageInfo_InsertCLI proto.InternalMessageInfo

func (m *InsertCLI) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *InsertCLI) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *InsertCLI) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *InsertCLI) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type TreeTokenOrIDInvalid struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *TreeTokenOrIDInvalid) Reset()      { *m = TreeTokenOrIDInvalid{} }
func (*TreeTokenOrIDInvalid) ProtoMessage() {}
func (*TreeTokenOrIDInvalid) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{26}
}
func (m *TreeTokenOrIDInvalid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreeTokenOrIDInvalid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreeTokenOrIDInvalid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TreeTokenOrIDInvalid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreeTokenOrIDInvalid.Merge(m, src)
}
func (m *TreeTokenOrIDInvalid) XXX_Size() int {
	return m.Size()
}
func (m *TreeTokenOrIDInvalid) XXX_DiscardUnknown() {
	xxx_messageInfo_TreeTokenOrIDInvalid.DiscardUnknown(m)
}

var xxx_messageInfo_TreeTokenOrIDInvalid proto.InternalMessageInfo

func (m *TreeTokenOrIDInvalid) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TreeTokenOrIDInvalid) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type DeleteCLI struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Key   int32  `protobuf:"varint,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *DeleteCLI) Reset()      { *m = DeleteCLI{} }
func (*DeleteCLI) ProtoMessage() {}
func (*DeleteCLI) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{27}
}
func (m *DeleteCLI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteCLI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteCLI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteCLI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteCLI.Merge(m, src)
}
func (m *DeleteCLI) XXX_Size() int {
	return m.Size()
}
func (m *DeleteCLI) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteCLI.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteCLI proto.InternalMessageInfo

func (m *DeleteCLI) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DeleteCLI) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *DeleteCLI) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

type SearchCLI struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Key   int32  `protobuf:"varint,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *SearchCLI) Reset()      { *m = SearchCLI{} }
func (*SearchCLI) ProtoMessage() {}
func (*SearchCLI) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{28}
}
func (m *SearchCLI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchCLI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchCLI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchCLI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchCLI.Merge(m, src)
}
func (m *SearchCLI) XXX_Size() int {
	return m.Size()
}
func (m *SearchCLI) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchCLI.DiscardUnknown(m)
}

var xxx_messageInfo_SearchCLI proto.InternalMessageInfo

func (m *SearchCLI) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SearchCLI) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *SearchCLI) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

type TraverseCLI struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *TraverseCLI) Reset()      { *m = TraverseCLI{} }
func (*TraverseCLI) ProtoMessage() {}
func (*TraverseCLI) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{29}
}
func (m *TraverseCLI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraverseCLI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraverseCLI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraverseCLI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraverseCLI.Merge(m, src)
}
func (m *TraverseCLI) XXX_Size() int {
	return m.Size()
}
func (m *TraverseCLI) XXX_DiscardUnknown() {
	xxx_messageInfo_TraverseCLI.DiscardUnknown(m)
}

var xxx_messageInfo_TraverseCLI proto.InternalMessageInfo

func (m *TraverseCLI) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TraverseCLI) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type DeleteTreeCLI struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *DeleteTreeCLI) Reset()      { *m = DeleteTreeCLI{} }
func (*DeleteTreeCLI) ProtoMessage() {}
func (*DeleteTreeCLI) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{30}
}
func (m *DeleteTreeCLI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTreeCLI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTreeCLI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTreeCLI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTreeCLI.Merge(m, src)
}
func (m *DeleteTreeCLI) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTreeCLI) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTreeCLI.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTreeCLI proto.InternalMessageInfo

func (m *DeleteTreeCLI) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DeleteTreeCLI) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type SuccessfulTreeDelete struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *SuccessfulTreeDelete) Reset()      { *m = SuccessfulTreeDelete{} }
func (*SuccessfulTreeDelete) ProtoMessage() {}
func (*SuccessfulTreeDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{31}
}
func (m *SuccessfulTreeDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessfulTreeDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuccessfulTreeDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuccessfulTreeDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessfulTreeDelete.Merge(m, src)
}
func (m *SuccessfulTreeDelete) XXX_Size() int {
	return m.Size()
}
func (m *SuccessfulTreeDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessfulTreeDelete.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessfulTreeDelete proto.InternalMessageInfo

func (m *SuccessfulTreeDelete) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SuccessfulTreeDelete) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type SuccessDeleteKey struct {
	Key   int32  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SuccessDeleteKey) Reset()      { *m = SuccessDeleteKey{} }
func (*SuccessDeleteKey) ProtoMessage() {}
func (*SuccessDeleteKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{32}
}
func (m *SuccessDeleteKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessDeleteKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuccessDeleteKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuccessDeleteKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessDeleteKey.Merge(m, src)
}
func (m *SuccessDeleteKey) XXX_Size() int {
	return m.Size()
}
func (m *SuccessDeleteKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessDeleteKey.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessDeleteKey proto.InternalMessageInfo

func (m *SuccessDeleteKey) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *SuccessDeleteKey) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ErrorKeyDoesNotExist struct {
	Key int32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ErrorKeyDoesNotExist) Reset()      { *m = ErrorKeyDoesNotExist{} }
func (*ErrorKeyDoesNotExist) ProtoMessage() {}
func (*ErrorKeyDoesNotExist) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb3889276909882a, []int{33}
}
func (m *ErrorKeyDoesNotExist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorKeyDoesNotExist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorKeyDoesNotExist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrorKeyDoesNotExist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorKeyDoesNotExist.Merge(m, src)
}
func (m *ErrorKeyDoesNotExist) XXX_Size() int {
	return m.Size()
}
func (m *ErrorKeyDoesNotExist) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorKeyDoesNotExist.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorKeyDoesNotExist proto.InternalMessageInfo

func (m *ErrorKeyDoesNotExist) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func init() {
	proto.RegisterType((*Add)(nil), "messages.Add")
	proto.RegisterType((*SuccessAdd)(nil), "messages.SuccessAdd")
	proto.RegisterType((*Find)(nil), "messages.Find")
	proto.RegisterType((*SuccessFindValue)(nil), "messages.SuccessFindValue")
	proto.RegisterType((*KeyValue)(nil), "messages.KeyValue")
	proto.RegisterType((*SetParentID)(nil), "messages.SetParentID")
	proto.RegisterType((*SetParentIDCustom)(nil), "messages.SetParentIDCustom")
	proto.RegisterType((*Traverse)(nil), "messages.Traverse")
	proto.RegisterType((*TraverseResponse)(nil), "messages.TraverseResponse")
	proto.RegisterType((*Trees)(nil), "messages.Trees")
	proto.RegisterType((*TreesResponse)(nil), "messages.TreesResponse")
	proto.RegisterType((*SendBackTreeResponse)(nil), "messages.SendBackTreeResponse")
	proto.RegisterType((*LookingForKeyLeft)(nil), "messages.LookingForKeyLeft")
	proto.RegisterType((*LookingForKeyRight)(nil), "messages.LookingForKeyRight")
	proto.RegisterType((*ErrorFindingValue)(nil), "messages.ErrorFindingValue")
	proto.RegisterType((*DeleteKey)(nil), "messages.DeleteKey")
	proto.RegisterType((*CouldNotFindKey)(nil), "messages.CouldNotFindKey")
	proto.RegisterType((*Cleanup)(nil), "messages.Cleanup")
	proto.RegisterType((*FinalCleanup)(nil), "messages.FinalCleanup")
	proto.RegisterType((*SetLeftMaxKey)(nil), "messages.SetLeftMaxKey")
	proto.RegisterType((*SetNewRoot)(nil), "messages.SetNewRoot")
	proto.RegisterType((*InfoSetLeftMaxKey)(nil), "messages.InfoSetLeftMaxKey")
	proto.RegisterType((*InfoSetLeftMaxKeyResponse)(nil), "messages.InfoSetLeftMaxKeyResponse")
	proto.RegisterType((*CreateNewTreeForCLI)(nil), "messages.CreateNewTreeForCLI")
	proto.RegisterType((*CreateNewTreeResponse)(nil), "messages.CreateNewTreeResponse")
	proto.RegisterType((*InsertCLI)(nil), "messages.InsertCLI")
	proto.RegisterType((*TreeTokenOrIDInvalid)(nil), "messages.TreeTokenOrIDInvalid")
	proto.RegisterType((*DeleteCLI)(nil), "messages.DeleteCLI")
	proto.RegisterType((*SearchCLI)(nil), "messages.SearchCLI")
	proto.RegisterType((*TraverseCLI)(nil), "messages.TraverseCLI")
	proto.RegisterType((*DeleteTreeCLI)(nil), "messages.DeleteTreeCLI")
	proto.RegisterType((*SuccessfulTreeDelete)(nil), "messages.SuccessfulTreeDelete")
	proto.RegisterType((*SuccessDeleteKey)(nil), "messages.SuccessDeleteKey")
	proto.RegisterType((*ErrorKeyDoesNotExist)(nil), "messages.ErrorKeyDoesNotExist")
}

func init() { proto.RegisterFile("tree.proto", fileDescriptor_cb3889276909882a) }

var fileDescriptor_cb3889276909882a = []byte{
	// 709 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x8e, 0x93, 0xa6, 0x4d, 0xa6, 0x14, 0x1a, 0x37, 0x85, 0x80, 0x90, 0x55, 0x96, 0x4b, 0x84,
	0x68, 0x25, 0xfa, 0x73, 0x41, 0x05, 0xd4, 0x26, 0x8d, 0x14, 0xa5, 0x84, 0xca, 0x8e, 0x10, 0x1c,
	0x97, 0x78, 0x92, 0x5a, 0x71, 0xbd, 0xd1, 0xee, 0x26, 0x6d, 0x38, 0xf1, 0x08, 0x3c, 0x00, 0x0f,
	0xc0, 0xa3, 0x70, 0xec, 0xb1, 0x47, 0xea, 0x5e, 0x38, 0xf6, 0x11, 0xd0, 0x3a, 0x76, 0xd2, 0x28,
	0x39, 0x38, 0xea, 0x6d, 0x66, 0x3c, 0xdf, 0xb7, 0xdf, 0xec, 0xcc, 0x8e, 0x01, 0x24, 0x47, 0xdc,
	0xea, 0x72, 0x26, 0x99, 0x9e, 0x39, 0x43, 0x21, 0x68, 0x1b, 0x05, 0xd9, 0x84, 0xd4, 0x81, 0x6d,
	0xeb, 0xab, 0x90, 0xea, 0xe0, 0xa0, 0xa0, 0x6d, 0x68, 0xc5, 0xb4, 0xa9, 0x4c, 0x3d, 0x0f, 0xe9,
	0x3e, 0x75, 0x7b, 0x58, 0x48, 0x6e, 0x68, 0xc5, 0xac, 0x39, 0x74, 0xc8, 0x2e, 0x80, 0xd5, 0x6b,
	0x36, 0x51, 0x88, 0x79, 0x50, 0x05, 0x58, 0xa8, 0x38, 0xde, 0x8c, 0x7c, 0xf2, 0x16, 0x56, 0x43,
	0x3e, 0x95, 0xf0, 0x59, 0x65, 0xc7, 0x66, 0xdd, 0x86, 0x4c, 0x0d, 0x07, 0xf3, 0x61, 0x56, 0x60,
	0xd9, 0x42, 0x79, 0x42, 0x39, 0x7a, 0xb2, 0x5a, 0x26, 0x1f, 0x20, 0x77, 0xc7, 0x2d, 0xf5, 0x84,
	0x64, 0x67, 0x8a, 0xab, 0xeb, 0xd8, 0x01, 0x57, 0xd6, 0x54, 0xa6, 0x5e, 0x80, 0x25, 0x6a, 0xdb,
	0x1c, 0x85, 0x08, 0xd9, 0x22, 0x97, 0x00, 0x64, 0x1a, 0x9c, 0xf6, 0x91, 0x0b, 0x24, 0xef, 0x61,
	0x35, 0xb2, 0x4d, 0x14, 0x5d, 0xe6, 0x09, 0xd4, 0x5f, 0xc1, 0x62, 0xa7, 0x7f, 0x42, 0x1d, 0x5e,
	0xd0, 0x36, 0x52, 0xc5, 0xe5, 0x6d, 0x7d, 0x2b, 0xba, 0xf9, 0xad, 0x48, 0xbb, 0x19, 0x66, 0x90,
	0x25, 0x48, 0x37, 0x38, 0xa2, 0x20, 0x7b, 0xb0, 0x12, 0x18, 0x23, 0x96, 0x87, 0x90, 0x0c, 0x05,
	0xa5, 0xcd, 0xa4, 0x63, 0xab, 0xda, 0x24, 0xeb, 0xa0, 0x17, 0xd5, 0x16, 0x38, 0xe4, 0x08, 0xf2,
	0x16, 0x7a, 0xf6, 0x21, 0x6d, 0x76, 0x14, 0x7c, 0x84, 0xde, 0x84, 0xb4, 0x6a, 0xbd, 0x08, 0x25,
	0x3c, 0x19, 0x4b, 0x98, 0x38, 0xc5, 0x1c, 0x66, 0x91, 0x35, 0xc8, 0x1d, 0x33, 0xd6, 0x71, 0xbc,
	0x76, 0x85, 0xf1, 0x1a, 0x0e, 0x8e, 0xb1, 0x25, 0x49, 0x1e, 0xf4, 0x89, 0xa0, 0xe9, 0xb4, 0x4f,
	0xa5, 0x4a, 0x3d, 0xe2, 0x9c, 0x71, 0xd5, 0x3b, 0xc7, 0x6b, 0x07, 0xe5, 0x90, 0x3d, 0xc8, 0x96,
	0xd1, 0x45, 0x89, 0x35, 0x1c, 0xe8, 0x8f, 0x61, 0xd1, 0x11, 0x8a, 0x21, 0x50, 0x9f, 0x31, 0x43,
	0x2f, 0xea, 0x57, 0x72, 0x3c, 0x09, 0x39, 0x78, 0x54, 0x62, 0x3d, 0xd7, 0xae, 0x33, 0xa9, 0xe8,
	0x6a, 0x38, 0x20, 0x2f, 0x61, 0xa9, 0xe4, 0x22, 0xf5, 0x7a, 0x5d, 0xd5, 0x81, 0x73, 0x7a, 0x97,
	0x28, 0x72, 0xc9, 0x17, 0x78, 0x50, 0x71, 0x3c, 0xea, 0x46, 0x99, 0x73, 0x74, 0x4f, 0x7f, 0x0e,
	0x59, 0x0b, 0x65, 0x83, 0x05, 0xbc, 0xa9, 0x80, 0x77, 0x1c, 0x20, 0x2f, 0x60, 0xc5, 0x42, 0xa9,
	0xcc, 0x8f, 0xf4, 0x42, 0x15, 0x33, 0x3d, 0xbe, 0xbf, 0x34, 0x00, 0x0b, 0x65, 0x1d, 0xcf, 0x4d,
	0xc6, 0xe4, 0x5c, 0x67, 0xbf, 0x86, 0x5c, 0x33, 0x98, 0xb7, 0x13, 0xc7, 0x6e, 0xb0, 0xe1, 0x8d,
	0x05, 0x1a, 0xb2, 0xe6, 0xf4, 0x07, 0x7d, 0x17, 0xd6, 0x87, 0xc1, 0x83, 0x21, 0x7c, 0x84, 0x58,
	0x08, 0x10, 0xb3, 0x3f, 0xaa, 0xfe, 0x54, 0xbd, 0x16, 0x9b, 0xa8, 0x82, 0x6c, 0xc2, 0xd3, 0xa9,
	0xe0, 0x68, 0x56, 0xa6, 0x4b, 0x7c, 0x03, 0x6b, 0x25, 0x8e, 0x54, 0x62, 0x1d, 0xcf, 0xd5, 0xbc,
	0x54, 0x18, 0x2f, 0x1d, 0x57, 0xf5, 0x67, 0x90, 0x71, 0x91, 0xb6, 0x2c, 0xe7, 0x3b, 0x86, 0xd9,
	0x23, 0x9f, 0xbc, 0x83, 0xf5, 0x09, 0xc8, 0x9c, 0x73, 0xfc, 0x15, 0xb2, 0x55, 0x4f, 0x20, 0x97,
	0xea, 0x9c, 0x58, 0x90, 0x48, 0x76, 0x6a, 0xc6, 0xf3, 0x5f, 0xb8, 0xfb, 0xfc, 0xf7, 0x21, 0xaf,
	0x04, 0x35, 0x14, 0xe8, 0x13, 0xaf, 0x96, 0xab, 0x5e, 0x9f, 0xba, 0x8e, 0x1d, 0x53, 0x58, 0x29,
	0x9a, 0xec, 0x7b, 0x08, 0x53, 0x24, 0x16, 0x52, 0xde, 0x3c, 0xbd, 0x0f, 0xc9, 0x0e, 0x2c, 0x47,
	0xab, 0x26, 0x36, 0x8d, 0x5a, 0x2b, 0x43, 0xf9, 0xea, 0x0a, 0xe2, 0xc3, 0xf6, 0x21, 0x1f, 0xae,
	0xe8, 0x56, 0xcf, 0x55, 0xd0, 0x70, 0x24, 0xe3, 0xa1, 0xc7, 0x0b, 0x7e, 0xbc, 0x14, 0xe2, 0x2e,
	0xeb, 0x22, 0xe4, 0x83, 0xf5, 0x52, 0xc3, 0x41, 0x99, 0xa1, 0xa8, 0x33, 0x79, 0x74, 0xe1, 0x08,
	0x39, 0x8d, 0x3f, 0xdc, 0xbd, 0xbc, 0x36, 0x12, 0x57, 0xd7, 0x46, 0xe2, 0xf6, 0xda, 0xd0, 0x7e,
	0xf8, 0x86, 0xf6, 0xdb, 0x37, 0xb4, 0x3f, 0xbe, 0xa1, 0x5d, 0xfa, 0x86, 0xf6, 0xd7, 0x37, 0xb4,
	0x7f, 0xbe, 0x91, 0xb8, 0xf5, 0x0d, 0xed, 0xe7, 0x8d, 0x91, 0xb8, 0xbc, 0x31, 0x12, 0x57, 0x37,
	0x46, 0xe2, 0xdb, 0x62, 0xf0, 0x33, 0xdc, 0xf9, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x96, 0x2c, 0xcd,
	0xc6, 0x1a, 0x07, 0x00, 0x00,
}

func (this *Add) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Add)
	if !ok {
		that2, ok := that.(Add)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *SuccessAdd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuccessAdd)
	if !ok {
		that2, ok := that.(SuccessAdd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Find) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Find)
	if !ok {
		that2, ok := that.(Find)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *SuccessFindValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuccessFindValue)
	if !ok {
		that2, ok := that.(SuccessFindValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *KeyValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyValue)
	if !ok {
		that2, ok := that.(KeyValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *SetParentID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetParentID)
	if !ok {
		that2, ok := that.(SetParentID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SetParentIDCustom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetParentIDCustom)
	if !ok {
		that2, ok := that.(SetParentIDCustom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	return true
}
func (this *Traverse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Traverse)
	if !ok {
		that2, ok := that.(Traverse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *TraverseResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TraverseResponse)
	if !ok {
		that2, ok := that.(TraverseResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.KvPair) != len(that1.KvPair) {
		return false
	}
	for i := range this.KvPair {
		if !this.KvPair[i].Equal(that1.KvPair[i]) {
			return false
		}
	}
	return true
}
func (this *Trees) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Trees)
	if !ok {
		that2, ok := that.(Trees)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *TreesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TreesResponse)
	if !ok {
		that2, ok := that.(TreesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *SendBackTreeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendBackTreeResponse)
	if !ok {
		that2, ok := that.(SendBackTreeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Trees) != len(that1.Trees) {
		return false
	}
	for i := range this.Trees {
		if !this.Trees[i].Equal(that1.Trees[i]) {
			return false
		}
	}
	return true
}
func (this *LookingForKeyLeft) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LookingForKeyLeft)
	if !ok {
		that2, ok := that.(LookingForKeyLeft)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *LookingForKeyRight) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LookingForKeyRight)
	if !ok {
		that2, ok := that.(LookingForKeyRight)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ErrorFindingValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ErrorFindingValue)
	if !ok {
		that2, ok := that.(ErrorFindingValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DeleteKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteKey)
	if !ok {
		that2, ok := that.(DeleteKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsLeft != that1.IsLeft {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *CouldNotFindKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CouldNotFindKey)
	if !ok {
		that2, ok := that.(CouldNotFindKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Cleanup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Cleanup)
	if !ok {
		that2, ok := that.(Cleanup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WasLeft != that1.WasLeft {
		return false
	}
	return true
}
func (this *FinalCleanup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FinalCleanup)
	if !ok {
		that2, ok := that.(FinalCleanup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.SetToLeft != that1.SetToLeft {
		return false
	}
	return true
}
func (this *SetLeftMaxKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetLeftMaxKey)
	if !ok {
		that2, ok := that.(SetLeftMaxKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *SetNewRoot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetNewRoot)
	if !ok {
		that2, ok := that.(SetNewRoot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.CustomPidToDelete != that1.CustomPidToDelete {
		return false
	}
	if this.CustomAddressToDelete != that1.CustomAddressToDelete {
		return false
	}
	return true
}
func (this *InfoSetLeftMaxKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InfoSetLeftMaxKey)
	if !ok {
		that2, ok := that.(InfoSetLeftMaxKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *InfoSetLeftMaxKeyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InfoSetLeftMaxKeyResponse)
	if !ok {
		that2, ok := that.(InfoSetLeftMaxKeyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *CreateNewTreeForCLI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateNewTreeForCLI)
	if !ok {
		that2, ok := that.(CreateNewTreeForCLI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LeafSize != that1.LeafSize {
		return false
	}
	return true
}
func (this *CreateNewTreeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateNewTreeResponse)
	if !ok {
		that2, ok := that.(CreateNewTreeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *InsertCLI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InsertCLI)
	if !ok {
		that2, ok := that.(InsertCLI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *TreeTokenOrIDInvalid) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TreeTokenOrIDInvalid)
	if !ok {
		that2, ok := that.(TreeTokenOrIDInvalid)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *DeleteCLI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteCLI)
	if !ok {
		that2, ok := that.(DeleteCLI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *SearchCLI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchCLI)
	if !ok {
		that2, ok := that.(SearchCLI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *TraverseCLI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TraverseCLI)
	if !ok {
		that2, ok := that.(TraverseCLI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *DeleteTreeCLI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteTreeCLI)
	if !ok {
		that2, ok := that.(DeleteTreeCLI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *SuccessfulTreeDelete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuccessfulTreeDelete)
	if !ok {
		that2, ok := that.(SuccessfulTreeDelete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *SuccessDeleteKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuccessDeleteKey)
	if !ok {
		that2, ok := that.(SuccessDeleteKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ErrorKeyDoesNotExist) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ErrorKeyDoesNotExist)
	if !ok {
		that2, ok := that.(ErrorKeyDoesNotExist)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *Add) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.Add{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuccessAdd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SuccessAdd{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Find) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.Find{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuccessFindValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SuccessFindValue{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.KeyValue{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetParentID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&messages.SetParentID{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetParentIDCustom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SetParentIDCustom{")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Traverse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&messages.Traverse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TraverseResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.TraverseResponse{")
	if this.KvPair != nil {
		s = append(s, "KvPair: "+fmt.Sprintf("%#v", this.KvPair)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Trees) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&messages.Trees{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.TreesResponse{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendBackTreeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.SendBackTreeResponse{")
	if this.Trees != nil {
		s = append(s, "Trees: "+fmt.Sprintf("%#v", this.Trees)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LookingForKeyLeft) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&messages.LookingForKeyLeft{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LookingForKeyRight) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&messages.LookingForKeyRight{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ErrorFindingValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&messages.ErrorFindingValue{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.DeleteKey{")
	s = append(s, "IsLeft: "+fmt.Sprintf("%#v", this.IsLeft)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CouldNotFindKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&messages.CouldNotFindKey{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Cleanup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.Cleanup{")
	s = append(s, "WasLeft: "+fmt.Sprintf("%#v", this.WasLeft)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FinalCleanup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&messages.FinalCleanup{")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "SetToLeft: "+fmt.Sprintf("%#v", this.SetToLeft)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetLeftMaxKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.SetLeftMaxKey{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetNewRoot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&messages.SetNewRoot{")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "CustomPidToDelete: "+fmt.Sprintf("%#v", this.CustomPidToDelete)+",\n")
	s = append(s, "CustomAddressToDelete: "+fmt.Sprintf("%#v", this.CustomAddressToDelete)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InfoSetLeftMaxKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&messages.InfoSetLeftMaxKey{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InfoSetLeftMaxKeyResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.InfoSetLeftMaxKeyResponse{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateNewTreeForCLI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.CreateNewTreeForCLI{")
	s = append(s, "LeafSize: "+fmt.Sprintf("%#v", this.LeafSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateNewTreeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.CreateNewTreeResponse{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InsertCLI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&messages.InsertCLI{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreeTokenOrIDInvalid) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.TreeTokenOrIDInvalid{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteCLI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&messages.DeleteCLI{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchCLI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&messages.SearchCLI{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TraverseCLI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.TraverseCLI{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteTreeCLI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.DeleteTreeCLI{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuccessfulTreeDelete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SuccessfulTreeDelete{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuccessDeleteKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SuccessDeleteKey{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ErrorKeyDoesNotExist) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.ErrorKeyDoesNotExist{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTree(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Add) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Add) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Add) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SuccessAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuccessAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Find) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Find) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Find) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SuccessFindValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessFindValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuccessFindValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetParentID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetParentID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetParentID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SetParentIDCustom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetParentIDCustom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetParentIDCustom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pid) > 0 {
		i -= len(m.Pid)
		copy(dAtA[i:], m.Pid)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Pid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Traverse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Traverse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Traverse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TraverseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraverseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraverseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KvPair) > 0 {
		for iNdEx := len(m.KvPair) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KvPair[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTree(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Trees) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trees) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trees) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TreesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TreesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SendBackTreeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendBackTreeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendBackTreeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Trees) > 0 {
		for iNdEx := len(m.Trees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTree(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LookingForKeyLeft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LookingForKeyLeft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LookingForKeyLeft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LookingForKeyRight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LookingForKeyRight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LookingForKeyRight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ErrorFindingValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorFindingValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrorFindingValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DeleteKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x10
	}
	if m.IsLeft {
		i--
		if m.IsLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CouldNotFindKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CouldNotFindKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CouldNotFindKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Cleanup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cleanup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cleanup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WasLeft {
		i--
		if m.WasLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinalCleanup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalCleanup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalCleanup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetToLeft {
		i--
		if m.SetToLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pid) > 0 {
		i -= len(m.Pid)
		copy(dAtA[i:], m.Pid)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Pid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetLeftMaxKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetLeftMaxKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetLeftMaxKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetNewRoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetNewRoot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetNewRoot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomAddressToDelete) > 0 {
		i -= len(m.CustomAddressToDelete)
		copy(dAtA[i:], m.CustomAddressToDelete)
		i = encodeVarintTree(dAtA, i, uint64(len(m.CustomAddressToDelete)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CustomPidToDelete) > 0 {
		i -= len(m.CustomPidToDelete)
		copy(dAtA[i:], m.CustomPidToDelete)
		i = encodeVarintTree(dAtA, i, uint64(len(m.CustomPidToDelete)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pid) > 0 {
		i -= len(m.Pid)
		copy(dAtA[i:], m.Pid)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Pid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InfoSetLeftMaxKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoSetLeftMaxKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfoSetLeftMaxKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *InfoSetLeftMaxKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoSetLeftMaxKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfoSetLeftMaxKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateNewTreeForCLI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateNewTreeForCLI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateNewTreeForCLI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeafSize != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.LeafSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateNewTreeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateNewTreeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateNewTreeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InsertCLI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertCLI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertCLI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x22
	}
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TreeTokenOrIDInvalid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeTokenOrIDInvalid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TreeTokenOrIDInvalid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteCLI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCLI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteCLI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchCLI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchCLI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchCLI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TraverseCLI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraverseCLI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraverseCLI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteTreeCLI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTreeCLI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteTreeCLI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SuccessfulTreeDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessfulTreeDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuccessfulTreeDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SuccessDeleteKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessDeleteKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuccessDeleteKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTree(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ErrorKeyDoesNotExist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorKeyDoesNotExist) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrorKeyDoesNotExist) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintTree(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTree(dAtA []byte, offset int, v uint64) int {
	offset -= sovTree(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Add) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *SuccessAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *Find) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	return n
}

func (m *SuccessFindValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *SetParentID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SetParentIDCustom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pid)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *Traverse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TraverseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KvPair) > 0 {
		for _, e := range m.KvPair {
			l = e.Size()
			n += 1 + l + sovTree(uint64(l))
		}
	}
	return n
}

func (m *Trees) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TreesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *SendBackTreeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Trees) > 0 {
		for _, e := range m.Trees {
			l = e.Size()
			n += 1 + l + sovTree(uint64(l))
		}
	}
	return n
}

func (m *LookingForKeyLeft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LookingForKeyRight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ErrorFindingValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DeleteKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsLeft {
		n += 2
	}
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	return n
}

func (m *CouldNotFindKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Cleanup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WasLeft {
		n += 2
	}
	return n
}

func (m *FinalCleanup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pid)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	if m.SetToLeft {
		n += 2
	}
	return n
}

func (m *SetLeftMaxKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	return n
}

func (m *SetNewRoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pid)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	l = len(m.CustomPidToDelete)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	l = len(m.CustomAddressToDelete)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *InfoSetLeftMaxKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *InfoSetLeftMaxKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	return n
}

func (m *CreateNewTreeForCLI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeafSize != 0 {
		n += 1 + sovTree(uint64(m.LeafSize))
	}
	return n
}

func (m *CreateNewTreeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *InsertCLI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *TreeTokenOrIDInvalid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *DeleteCLI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	return n
}

func (m *SearchCLI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	return n
}

func (m *TraverseCLI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *DeleteTreeCLI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *SuccessfulTreeDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTree(uint64(m.Id))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *SuccessDeleteKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTree(uint64(l))
	}
	return n
}

func (m *ErrorKeyDoesNotExist) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovTree(uint64(m.Key))
	}
	return n
}

func sovTree(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTree(x uint64) (n int) {
	return sovTree(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Add) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Add{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuccessAdd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuccessAdd{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Find) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Find{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuccessFindValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuccessFindValue{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KeyValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KeyValue{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetParentID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetParentID{`,
		`}`,
	}, "")
	return s
}
func (this *SetParentIDCustom) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetParentIDCustom{`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Traverse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Traverse{`,
		`}`,
	}, "")
	return s
}
func (this *TraverseResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForKvPair := "[]*KeyValue{"
	for _, f := range this.KvPair {
		repeatedStringForKvPair += strings.Replace(f.String(), "KeyValue", "KeyValue", 1) + ","
	}
	repeatedStringForKvPair += "}"
	s := strings.Join([]string{`&TraverseResponse{`,
		`KvPair:` + repeatedStringForKvPair + `,`,
		`}`,
	}, "")
	return s
}
func (this *Trees) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Trees{`,
		`}`,
	}, "")
	return s
}
func (this *TreesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreesResponse{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendBackTreeResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTrees := "[]*TreesResponse{"
	for _, f := range this.Trees {
		repeatedStringForTrees += strings.Replace(f.String(), "TreesResponse", "TreesResponse", 1) + ","
	}
	repeatedStringForTrees += "}"
	s := strings.Join([]string{`&SendBackTreeResponse{`,
		`Trees:` + repeatedStringForTrees + `,`,
		`}`,
	}, "")
	return s
}
func (this *LookingForKeyLeft) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookingForKeyLeft{`,
		`}`,
	}, "")
	return s
}
func (this *LookingForKeyRight) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookingForKeyRight{`,
		`}`,
	}, "")
	return s
}
func (this *ErrorFindingValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ErrorFindingValue{`,
		`}`,
	}, "")
	return s
}
func (this *DeleteKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteKey{`,
		`IsLeft:` + fmt.Sprintf("%v", this.IsLeft) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CouldNotFindKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CouldNotFindKey{`,
		`}`,
	}, "")
	return s
}
func (this *Cleanup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Cleanup{`,
		`WasLeft:` + fmt.Sprintf("%v", this.WasLeft) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FinalCleanup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FinalCleanup{`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`SetToLeft:` + fmt.Sprintf("%v", this.SetToLeft) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetLeftMaxKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetLeftMaxKey{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetNewRoot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetNewRoot{`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`CustomPidToDelete:` + fmt.Sprintf("%v", this.CustomPidToDelete) + `,`,
		`CustomAddressToDelete:` + fmt.Sprintf("%v", this.CustomAddressToDelete) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InfoSetLeftMaxKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InfoSetLeftMaxKey{`,
		`}`,
	}, "")
	return s
}
func (this *InfoSetLeftMaxKeyResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InfoSetLeftMaxKeyResponse{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateNewTreeForCLI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateNewTreeForCLI{`,
		`LeafSize:` + fmt.Sprintf("%v", this.LeafSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateNewTreeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateNewTreeResponse{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InsertCLI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InsertCLI{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeTokenOrIDInvalid) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeTokenOrIDInvalid{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteCLI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteCLI{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchCLI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SearchCLI{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TraverseCLI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TraverseCLI{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteTreeCLI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteTreeCLI{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuccessfulTreeDelete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuccessfulTreeDelete{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuccessDeleteKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuccessDeleteKey{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ErrorKeyDoesNotExist) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ErrorKeyDoesNotExist{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTree(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Add) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Add: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Add: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Find) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Find: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Find: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessFindValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessFindValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessFindValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetParentID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetParentID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetParentID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetParentIDCustom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetParentIDCustom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetParentIDCustom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Traverse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Traverse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Traverse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraverseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraverseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraverseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KvPair = append(m.KvPair, &KeyValue{})
			if err := m.KvPair[len(m.KvPair)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trees) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trees: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trees: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendBackTreeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendBackTreeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendBackTreeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trees = append(m.Trees, &TreesResponse{})
			if err := m.Trees[len(m.Trees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookingForKeyLeft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookingForKeyLeft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookingForKeyLeft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookingForKeyRight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookingForKeyRight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookingForKeyRight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorFindingValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorFindingValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorFindingValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeft = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CouldNotFindKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CouldNotFindKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CouldNotFindKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cleanup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cleanup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cleanup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WasLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WasLeft = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalCleanup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalCleanup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalCleanup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetToLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetToLeft = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetLeftMaxKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetLeftMaxKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetLeftMaxKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetNewRoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetNewRoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetNewRoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPidToDelete", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPidToDelete = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomAddressToDelete", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomAddressToDelete = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoSetLeftMaxKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoSetLeftMaxKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoSetLeftMaxKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoSetLeftMaxKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoSetLeftMaxKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoSetLeftMaxKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateNewTreeForCLI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateNewTreeForCLI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateNewTreeForCLI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafSize", wireType)
			}
			m.LeafSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateNewTreeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateNewTreeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateNewTreeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertCLI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertCLI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertCLI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeTokenOrIDInvalid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeTokenOrIDInvalid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeTokenOrIDInvalid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCLI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCLI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCLI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchCLI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchCLI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchCLI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraverseCLI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraverseCLI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraverseCLI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTreeCLI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTreeCLI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTreeCLI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessfulTreeDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessfulTreeDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessfulTreeDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessDeleteKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessDeleteKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessDeleteKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorKeyDoesNotExist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorKeyDoesNotExist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorKeyDoesNotExist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTree(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTree
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTree
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTree
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTree
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTree
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTree
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTree        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTree          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTree = fmt.Errorf("proto: unexpected end of group")
)
